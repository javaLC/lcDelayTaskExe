# 基本需求
  针对本次题设：基于 Redis、Rocktmq，springboot实现一个延迟任务执行框架
  1. 使用方可以指定一个任务的延迟时间；
  2. 实现一个 client，方便使用方使用；
  3. 设计回调机制，方便使用方实现业务逻辑；

# 概要设计
  <https://note.youdao.com/ynoteshare1/index.html?id=89cea342f70432d7822466e9ee4577c3&type=note>

# 项目实现过程
## 项目周期
  这两天经历了从0到1到过程：基本设计，项目工程，redis，rocketmq环境搭建。
  
## 整体设计概述
### 框架功能使用点
  1. rocketmq：通信（如果往大的或抽象来说就是系统交互协议）。提交任务，唤起任务执行。  
  2. redis：存储。利用有序集合，对延迟任务，按时间先后进行排序存储  
  3. Springboot：略
### 功能用例
  > 客户端
  >> 1. 提交任务  
  >> 2. 执行任务，回调
  
  > 服务端
  >> 1. 任务管理（主要是添加）  
  >> 2. 任务调度，策略(延迟）
### 延迟任务流转
  > 任务提交流程
  >> 1. client -> 提交延迟任务(mq方式通知)    
  >> 2. server -> 收到任务提交 -> if(延迟 <= 0) 则立刻发出任务执行(mq) else 存入redis。  
  
  > 任务执行/回调
  >> 1. server -> 定时拉取(并移除)未来N秒的任务 -> 计算延迟，if(已经到了) 立刻发出任务执行(mq) else 放入延迟调度线程池。延迟到期，发出任务执行(mq)  
  >> 2. client -> 收到任务执行 -> 查询任务对应函数 -> 执行任务 -> 如果注册了回调则执行回调  
  
## 工程代码说明
  项目分为三个模块：deleyCommon，delayClient，delayServer
  > delayCommon
  >> 1. 封装了client和server共同模块  
  >> 2. msg包：简单来说，可以认为是一种《交互报文》定义。 InvokeType定义了消息类型  
  >> 3. rocket包：简单来说，可以认为是一种《交互通信协议》。  
  
  > delayClient
  >> 1. job包：对任务/回调进行统一定义。统一称为job  
  >> 2. invoke包：客户端注册job管理；依赖mq通信，实现执行任务和回调。  
 
  > delayServer
  >> 1. task包：任务(job)管理：统一定义Task模型；接收任务等。  
  >> 2. redis包：底层数据存储支持  
  >> 3. dispatch包：任务调度，策略。  
 
# 总结
  虽然本次题设是：延迟任务框架。本质上可以是分布式任务调度系统的一个缩影。延迟调用中的延迟只是调度的一种策略。对于任务调度还会有更多的
  策略：定点，频次等。不过根据题设，暂无需过度设计。  
  针对本次题设代码实现，还有很大对优化空间
  > 项目与设计
  >> 1. 一类多职责(如：com.lc.delay.frame.delayserver.dispatch.RocketMqInvokeDispatcher)。  
  >> 2. 关于client便捷使用上，应打包jar，以依赖使用。可以将依赖的bean，统一注册。可以使用springboot的起步依赖。可参考：RedisAutoConfiguration  
  >> 3. mq的配置和使用上。可以进一步优化。特别是针对client端  
  >> 4. 命名上也有需要进行优化  
  >> 5. pom文件关系
  >> 6. 设计上还可以根据领域进一步抽象细化
  
  > 功能上优化  
  >> 延迟精度影响  
  >>> 1. mq，redis存储/获取的耗时
  >>> 2. 服务端，延迟任务扫描（目前1秒）和延迟执行。  
  >>> 3. 日志中服务器和客户端间时差

  